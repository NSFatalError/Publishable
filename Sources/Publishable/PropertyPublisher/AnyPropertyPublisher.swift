//
//  AnyPropertyPublisher.swift
//  Publishable
//
//  Created by Kamil Strzelecki on 17/01/2025.
//  Copyright Â© 2025 Kamil Strzelecki. All rights reserved.
//

import Combine

/// An object that exposes `Combine` publishers for  ``willChange`` and ``didChange`` events.
///
/// Subclasses of this class are generated by the ``Publishable()`` macro,
/// and provide publishers for all mutable instance properties of the type the macro is applied to.
///
open class AnyPropertyPublisher<Object: AnyObject> {

    private let _willChange = PassthroughSubject<Object, Never>()
    private let _didChange = PassthroughSubject<Object, Never>()

    /// Emits the `Object` **before** any of its stored properties are assigned a new value.
    ///
    public var willChange: AnyPublisher<Object, Never> {
        _willChange.eraseToAnyPublisher()
    }

    /// Emits the `Object` **after** any of its stored properties are assigned a new value.
    ///
    public var didChange: AnyPublisher<Object, Never> {
        _didChange.eraseToAnyPublisher()
    }

    private var pendingModifications = 0
    private unowned let object: Object

    @_documentation(visibility: private)
    public init(object: Object) {
        self.object = object
    }

    deinit {
        _willChange.send(completion: .finished)
        _didChange.send(completion: .finished)
    }
}

extension AnyPropertyPublisher {

    func beginModifications() {
        if pendingModifications == 0 {
            _willChange.send(object)
        }
        pendingModifications += 1
    }

    func endModifications() {
        pendingModifications -= 1
        if pendingModifications == 0 {
            _didChange.send(object)
        }
    }
}

// swiftlint:disable identifier_name

extension AnyPropertyPublisher {

    public func _storedPropertyPublisher<T>(
        _ subject: PassthroughSubject<T, Never>,
        for keyPath: KeyPath<Object, T>
    ) -> AnyPublisher<T, Never> {
        subject
            .prepend(object[keyPath: keyPath])
            .eraseToAnyPublisher()
    }

    public func _storedPropertyPublisher<T: Equatable>(
        _ subject: PassthroughSubject<T, Never>,
        for keyPath: KeyPath<Object, T>
    ) -> AnyPublisher<T, Never> {
        subject
            .prepend(object[keyPath: keyPath])
            .removeDuplicates()
            .eraseToAnyPublisher()
    }
}

extension AnyPropertyPublisher {

    public func _computedPropertyPublisher<T>(
        for keyPath: KeyPath<Object, T>
    ) -> AnyPublisher<T, Never> {
        _didChange
            .prepend(object)
            .map { $0[keyPath: keyPath] }
            .eraseToAnyPublisher()
    }

    public func _computedPropertyPublisher<T: Equatable>(
        for keyPath: KeyPath<Object, T>
    ) -> AnyPublisher<T, Never> {
        _didChange
            .prepend(object)
            .map { $0[keyPath: keyPath] }
            .removeDuplicates()
            .eraseToAnyPublisher()
    }
}

// swiftlint:enable identifier_name
